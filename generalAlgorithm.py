# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11y-GY1zKWvTkLxh2hCedsdXKouGuK4qp
"""
import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
from skimage.filters import threshold_otsu, threshold_isodata, threshold_niblack, threshold_multiotsu, \
    threshold_sauvola, unsharp_mask
from skimage.morphology import skeletonize
import tkinter as tk
from PIL import Image, ImageTk


def extract_square_around_point(matrix, x, y, n):
    half_n = n // 2

    # Check boundaries
    x_start = max(0, x - half_n)
    x_end = min(matrix.shape[0], x + half_n + 1)
    y_start = max(0, y - half_n)
    y_end = min(matrix.shape[1], y + half_n + 1)

    # Extract the square matrix within boundaries
    square_matrix = matrix[x_start:x_end, y_start:y_end]

    # Pad if necessary to ensure a square matrix of size (n x n)
    pad_width = n - square_matrix.shape[0], n - square_matrix.shape[1]
    if pad_width[0] > 0 or pad_width[1] > 0:
        square_matrix = np.pad(square_matrix, ((0, pad_width[0]), (0, pad_width[1])), mode='constant',
                               constant_values=0)

    return square_matrix


def findGridLine(img):
    img = cv.bitwise_not(img)
    bw = cv.adaptiveThreshold(img, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 15, -2)

    horizontal = np.copy(bw)
    vertical = np.copy(bw)

    cols = horizontal.shape[1]
    horizontal_size = cols // 30
    horizontalStructure = cv.getStructuringElement(cv.MORPH_RECT, (horizontal_size, 1))
    horizontal = cv.erode(horizontal, horizontalStructure)
    horizontal = cv.dilate(horizontal, horizontalStructure)

    rows = vertical.shape[0]
    verticalsize = rows // 30
    verticalStructure = cv.getStructuringElement(cv.MORPH_RECT, (1, verticalsize))
    vertical = cv.erode(vertical, verticalStructure)
    vertical = cv.dilate(vertical, verticalStructure)

    vertical = cv.bitwise_not(vertical)

    edges = cv.adaptiveThreshold(vertical, 255, cv.ADAPTIVE_THRESH_MEAN_C, cv.THRESH_BINARY, 3, -2)

    kernel = np.ones((2, 2), np.uint8)
    edges = cv.dilate(edges, kernel)

    smooth = np.copy(vertical)
    smooth = cv.blur(smooth, (2, 2))

    (rows, cols) = np.where(edges != 0)
    vertical[rows, cols] = smooth[rows, cols]

    grid = cv.bitwise_and(~horizontal, vertical)

    return grid


"""Reading Image"""

originalImage = cv.imread(f"images/grid.jpg", 0)
originalImage = cv.resize(originalImage, (720, 560))

"""Sharpening Edges"""

sharp_image = unsharp_mask(originalImage, radius=10, amount=3)
sharp_image = cv.normalize(sharp_image, None, 0, 255, cv.NORM_MINMAX)
# cv.imshow("image",sharp_image)
cv.waitKey(0)
cv.destroyAllWindows()

"""Applying Bilateral Filter for bluring while preserving edges"""
d = 1
sigmaSpace = 100
sigmaColor = 10
# bilateraledImg = cv.bilateralFilter(cv.convertScaleAbs(sharp_image), d, sigmaColor, sigmaSpace)
bilateraledImg = cv.bilateralFilter(cv.convertScaleAbs(sharp_image), 55, 84, 75)
gridLine = findGridLine(bilateraledImg)

#
# """Applying isodata threshold to get binary image with only curve"""

mask = threshold_isodata(bilateraledImg)
thresholdImg = (bilateraledImg <= mask).astype(np.uint8) * 255
tmp = ~cv.bitwise_or(~thresholdImg, ~gridLine)

# t = np.where(tmp > 0, 255,0).astype(np.uint8)
cv.imshow("image",tmp)
cv.waitKey(0)
cv.destroyAllWindows()
# """Erode Image to remove noise"""
#
# erodedImg = cv.morphologyEx(thresholdImg, cv.MORPH_ERODE, np.ones((3, 3), dtype=np.uint8))
# # cv.imshow("image",erodedImg)
# cv.waitKey(0)
# cv.destroyAllWindows()
#
# """Apply skeletonize algorithm to result in only pixel width representation of curve"""
#
# skeleton = skeletonize(erodedImg, method="lee")
# indexes = np.column_stack(np.where(skeleton == 255))
# for i, j in indexes:
#     mat = extract_square_around_point(skeleton, i, j, 11)
#     if np.sum(mat) <= 255:
#         skeleton[i, j] = 0
#
# # cv.imshow("image",skeleton)
# cv.waitKey(0)
# cv.destroyAllWindows()
